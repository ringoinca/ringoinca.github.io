<!DOCTYPE html>
<!-- Akai (pandoc HTML5 template)
     designer:     soimort
     last updated: 2016-05-06
     last adapted: 2016-11-01 -->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <meta name="author" content="Mort Yao">
    <meta name="dcterms.date" content="2017-11-09">
    <title>Underrated Gems (1)</title>
    <link rel="canonical" href="https://www.soimort.org/notes/171109">
    <style type="text/css">code { white-space: pre; }</style>
    <link rel="stylesheet" href="//cdn.soimort.org/normalize/5.0.0/normalize.min.css">
    <link rel="stylesheet" href="//cdn.soimort.org/fonts/latest/URW-Palladio-L.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/__/css/style.css">
    <link rel="stylesheet" href="/__/css/pygments.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
    <script src="//cdn.soimort.org/jk/latest/jk.min.js"></script>
    <script src="/__/js/main.js"></script>
    <link rel="icon" href="/favicon.png">
    <link rel="apple-touch-icon" href="/favicon.png">
    <link rel="alternate" type="application/atom+xml" href="/feed.atom">
  </head>
  <body>
    <article>
      <header>
        <h1 class="title"><a href="https://www.soimort.org/notes/171109">Underrated Gems (1)</a></h1>
        <h1 class="subtitle"><a href="https://www.soimort.org/notes/171109">Tarski’s undefinability theorem</a></h1>
        <address class="author">Mort Yao</address>
        <h3 class="date">2017-11-09</h3>
      </header>
      <div id="content">
<p><small></p>
<blockquote>
<p>In a listless afternoon I questioned myself: What are some of the most neglected theorems that deserve more attention? Many famous old theorems in mathematics as I recalled, are about some kinds of <em>impossibilities</em>: <span class="math inline">\(\sqrt{2}\)</span> is irrational, <span class="math inline">\(\pi\)</span> is transcendental, polynomial equations of degree 5 or higher are generally insolvable, squaring the circle is impossible, Fermat’s last theorem, etc; by arguing about impossibility they’ve landscaped lots of math subfields in a revolutionary way. Compared to mathematics, formal logic is a relatively young field, not really fruitful before Frege, and the study on the theory of computation is even less cultivated, with quite a bunch of landmarking results yet underrated or poorly informed. Among those neglected theorems in logic and computation, I decided to do a write-up on each one I ever heard of, to help myself understand them better. Undoubtedly, they ought to be brought to the limelight and made better understood by working mathematicians and programmers nowadays. </small></p>
</blockquote>
<hr />
<p>It should be put in the first paragraph of the preface to <em><a href="https://en.wikipedia.org/wiki/Paul_Erdős#Personality">The Book</a> on logic</em>, if there could be one, that <em>truth in any language cannot be defined in the language itself</em>. We have the classical <em>liar’s sentence</em> which says that “This sentence is false”. If this kind of inconsistency does not seem too disastrous to bug you yet, as you may guarantee not to involve yourself into any circular reasoning, then think about the following <em>truth-teller’s sentence</em>:</p>
<p style="text-align:center !important;text-indent:0 !important">If this sentence is true, then God exists.</p>
<p>Symbolically,</p>
<p><span class="math display">\[\sigma = (\text{True}(\sigma) \to \exists x\,\text{Godlike}(x))
\]</span></p>
<p>If you take this sentence to be false, then since it is a material conditional the only way it can ever be false is that the antecedent (<span class="math inline">\(\text{True}(\sigma)\)</span>) is true but the consequent (<span class="math inline">\(\exists x\,\text{Godlike}(x)\)</span>) is false. However, from that <span class="math inline">\(\text{True}(\sigma)\)</span> is true we would immediately get that <span class="math inline">\(\sigma\)</span> is true, which contradicts our assumption that <span class="math inline">\(\sigma\)</span> is false. On the other hand, if you take this sentence to be true, then everything should work perfectly: <span class="math inline">\(\text{True}(\sigma)\)</span> is true, <span class="math inline">\(\exists x\,\text{Godlike}(x)\)</span> is also true, therefore the whole sentence <span class="math inline">\(\sigma\)</span> is true, which just verifies the fact that <span class="math inline">\(\text{True}(\sigma)\)</span> is true. Therefore, to maintain logical consistency in our reasoning, the only choice for a rational person is to accept the truth of <span class="math inline">\(\exists x\,\text{Godlike}(x)\)</span>, i.e., “God exists.”</p>
<p>This is not really about the ontological argument of God’s existence; it’s about how the inherent inconsistency of an unrestricted language can lead to any random truth trivially (<em>ex contradictione quodlibet</em>). If you believe that the above argument is all reasonable and God indeed exists, try yourself on the following sentence:</p>
<p style="text-align:center !important;text-indent:0 !important">If this sentence is true, then Satan rules the world.</p>
<p>Let’s say, get it over since natural language is so tricky and facile but no one is really hurt by its expressive power.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> The sure thing is, no serious mathematician wants to derive ridiculous random facts (e.g., if some self-referential proposition is true, then “<span class="math inline">\(2 + 2 = 3\)</span>”), so in a <em>formal language</em> we are obliged to have a metatheorem like:</p>
<p><strong>Undefinability theorem (Tarski 1936).</strong> Let <span class="math inline">\(\mathcal{L}\)</span> be a formal language, and let <span class="math inline">\(\mathfrak{A}\)</span> be an <span class="math inline">\(\mathcal{L}\)</span>-structure, with its theory <span class="math inline">\(\operatorname{Th}\mathfrak{A}\)</span> capable of representing all computable functions. A Gödel numbering <span class="math inline">\(\mathfrak{g}(\phi)\)</span> is defined for every <span class="math inline">\(\mathcal{L}\)</span>-formula <span class="math inline">\(\phi\)</span>. There is no formula <span class="math inline">\(\text{True}(n)\)</span> such that for every <span class="math inline">\(\mathcal{L}\)</span>-formula <span class="math inline">\(\varphi\)</span>, <span class="math inline">\(\text{True}(\mathfrak{g}(\varphi)) \leftrightarrow \varphi\)</span>.</p>
<p>Before proceeding with the proof of Tarski’s undefinability theorem, we get our terminology straight first and prove a very important lemma, namely the <em>diagonal lemma</em>. The definitions of language, structure and theory are already made in <a href="/mst/7/">Mst. #7</a>. The capability of representing all computable functions can be informally understood as, for every Turing-computable function <span class="math inline">\(f : x \mapsto y\)</span>, there is an <span class="math inline">\(\mathcal{L}\)</span>-formula <span class="math inline">\(\gamma_f\)</span> such that <span class="math inline">\(\gamma_f(x, y) \in \operatorname{Th}\mathfrak{A} \leftrightarrow y = f(x)\)</span>.</p>
<p>A Gödel numbering in a formal language <span class="math inline">\(\mathcal{L}\)</span> is an injective function <span class="math inline">\(\mathfrak{g} : \Phi \to \mathbb{N}\)</span> that maps every <span class="math inline">\(\mathcal{L}\)</span>-formula to a unique natural number <span class="math inline">\(n \in \mathbb{N}\)</span>. It may be defined in any way that satisfies the desired injective property. For example, in a first-order language <span class="math inline">\(\mathcal{L}_\text{Set}\)</span> consisting of only variables <span class="math inline">\(x_i\)</span> (<span class="math inline">\(i = 0, 1, 2, \dots\)</span>), two connective symbols <span class="math inline">\(\{ \to, \neg \}\)</span>, the equality symbol <span class="math inline">\(=\)</span>, the quantifier symbol <span class="math inline">\(\forall\)</span> and a predicate symbol <span class="math inline">\(\in\)</span>, one possible Gödel numbering function may be defined inductively as</p>
<span class="math display">\[\begin{align*}
\mathfrak{g}(x_i) &amp;= 2^0 \cdot 3^i \\
\mathfrak{g}(= t_1 t_2) &amp;= 2^1 \cdot 3^{\mathfrak{g}(t_1)} \cdot 5^{\mathfrak{g}(t_2)} \\
\mathfrak{g}(\in t_1 t_2) &amp;= 2^2 \cdot 3^{\mathfrak{g}(t_1)} \cdot 5^{\mathfrak{g}(t_2)} \\
\mathfrak{g}((\neg \psi)) &amp;= 2^3 \cdot 3^{\mathfrak{g}(\psi)} \\
\mathfrak{g}((\psi \to \theta)) &amp;= 2^4 \cdot 3^{\mathfrak{g}(\psi)} \cdot 5^{\mathfrak{g}(\theta)} \\
\mathfrak{g}(\forall x_i \psi) &amp;= 2^5 \cdot 3^i \cdot 5^{\mathfrak{g}(\psi)} \\
\end{align*}\]</span>
<p style="text-align:right !important;text-indent:0 !important">(*)</p>
<p><strong>Claim 1.</strong> (*) defines a Gödel numbering <span class="math inline">\(\mathfrak{g}\)</span> on the language <span class="math inline">\(\mathcal{L}_\text{Set}\)</span>. That is, for any <span class="math inline">\(\mathcal{L}_\text{Set}\)</span>-formulas <span class="math inline">\(\varphi_1\)</span> and <span class="math inline">\(\varphi_2\)</span>, if <span class="math inline">\(\mathfrak{g}(\varphi_1) = \mathfrak{g}(\varphi_2)\)</span>, then <span class="math inline">\(\varphi_1 \cong \varphi_2\)</span>.</p>
<p><strong>Proof idea.</strong> By structural induction on the formula and the <a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic">fundamental theorem of arithmetic</a> (every integer greater than 1 has a unique prime-factorization).</p>
<p><strong>Example 2.</strong> The Gödel number of formula <span class="math inline">\(\forall x_0 (\neg \in x_0 x_0)\)</span> using (*) is</p>
<span class="math display">\[\begin{align*}
\mathfrak{g}(\forall x_0 (\neg \in x_0 x_0))
&amp;= 2^5 \cdot 3^0 \cdot 5^{\mathfrak{g}(\neg \in x_0 x_0)}
= 2^5 \cdot 3^0 \cdot 5^{2^3 \cdot 3^{\mathfrak{g}(\in x_0 x_0)}}
= 2^5 \cdot 3^0 \cdot 5^{2^3 \cdot 3^{2^2 \cdot 3^{2^0 \cdot 3^0} \cdot 5^{2^0 \cdot 3^0}}} \\
&amp;= 2^5 \cdot 3^0 \cdot 5^{2^3 \cdot 3^{60}} \\
&amp;= 32 \cdot 5^{339129266201729628114355465608}
\end{align*}\]</span>
<p>Note that the choice of our numbering function is purely technical; it doesn’t make any difference if we choose another set of prime numbers <span class="math inline">\(\{5, 7, 11\}\)</span> instead of <span class="math inline">\(\{2, 3, 5\}\)</span> as basis, as long as the decomposition of a Gödel number is unique. (Of course, such numbers would be even bigger.)</p>
<p>So, what is the whole point of this numbering thing, you might ask? As is shown in Example 2, a simple formula can yield a Gödel number which is insanely large (no kidding, even <em>much</em> greater than the total number of atoms in the universe!). We don’t actually use these numbers; we construct them just to convince ourselves that we <em>can</em> encode virtually any theory into the theory of arithmetic, or literally, strings into natural numbers. The overwhelming cost (complexity) is not of our concern for now. Hence, from now on, we can virtually reduce any problem in a formal language (set theory, type theory, analysis, geometry, …) to an arithmetical problem, i.e., a problem simply about manipulating and deciding on natural numbers.</p>
<p><strong>Diagonal lemma (Carnap 1934).</strong> Let <span class="math inline">\(\mathcal{L}_\text{A}\)</span> be a first-order language of arithmetic, and let <span class="math inline">\(\mathfrak{A}\)</span> be an <span class="math inline">\(\mathcal{L}_\text{A}\)</span>-structure, with its theory <span class="math inline">\(\operatorname{Th}\mathfrak{A}\)</span> capable of representing all computable functions. Let <span class="math inline">\(\phi\)</span> be an <span class="math inline">\(\mathcal{L}_\text{A}\)</span>-formula with one free variable. There is a sentence <span class="math inline">\(\psi\)</span> such that <span class="math inline">\(\psi \leftrightarrow \phi(\mathfrak{g}(\psi))\)</span> in <span class="math inline">\(\operatorname{Th}\mathfrak{A}\)</span>.</p>
<p><strong>Proof.</strong> Let <span class="math inline">\(f\)</span> be a total function defined on <span class="math inline">\(|\mathfrak{A}| = \mathbb{N}\)</span>: <span class="math display">\[f(\mathfrak{g}(\theta)) = \mathfrak{g}(\theta(\mathfrak{g}(\theta)))\]</span> for each <span class="math inline">\(\mathcal{L}_\text{A}\)</span>-formula <span class="math inline">\(\theta\)</span> with one free variable; otherwise, define <span class="math inline">\(f(n) = 0\)</span>.</p>
<p>Since <span class="math inline">\(f\)</span> is a computable function, there is a formula <span class="math inline">\(\gamma_f\)</span> representing <span class="math inline">\(f\)</span> in <span class="math inline">\(\operatorname{Th}\mathfrak{A}\)</span>. That is, for each formula <span class="math inline">\(\theta\)</span>, we have in <span class="math inline">\(\operatorname{Th}\mathfrak{A}\)</span> <span class="math display">\[\forall y\,(\gamma_f(\mathfrak{g}(\theta), y) \leftrightarrow y = f(\mathfrak{g}(\theta)))\]</span> which is just <span class="math display">\[\forall y\,(\gamma_f(\mathfrak{g}(\theta), y) \leftrightarrow y = \mathfrak{g}(\theta(\mathfrak{g}(\theta))))\]</span> Define the formula <span class="math inline">\(\beta\)</span> (with one free variable) as <span class="math display">\[\beta(z) = \forall y\,(\gamma_f(z,y) \to \phi(y))\]</span> Then we have in <span class="math inline">\(\operatorname{Th}\mathfrak{A}\)</span> <span class="math display">\[\beta(\mathfrak{g}(\theta)) \leftrightarrow \forall y\,(y = \mathfrak{g}(\theta(\mathfrak{g}(\theta))) \to \phi(y))\]</span> which is just <span class="math display">\[\beta(\mathfrak{g}(\theta)) \leftrightarrow \phi(\mathfrak{g}(\theta(\mathfrak{g}(\theta))))\]</span> Since <span class="math inline">\(\theta\)</span> can be any <span class="math inline">\(\mathcal{L}_\text{A}\)</span>-formula, let <span class="math inline">\(\theta = \beta\)</span>. Then we have in <span class="math inline">\(\operatorname{Th}\mathfrak{A}\)</span> <span class="math display">\[\beta(\mathfrak{g}(\beta)) \leftrightarrow \phi(\mathfrak{g}(\beta(\mathfrak{g}(\beta))))\]</span> Let <span class="math inline">\(\psi = \beta(\mathfrak{g}(\beta))\)</span>. Thus we have in <span class="math inline">\(\operatorname{Th}\mathfrak{A}\)</span> <span class="math display">\[\psi \leftrightarrow \phi(\mathfrak{g}(\psi))\]</span> Therefore we obtain <span class="math inline">\(\psi\)</span> which is the required sentence (“fixed point”). <p style='text-align:right !important;text-indent:0 !important;position:relative;top:-1em'>&#9632;</p></p>
<p>Now we are all set to prove the undefinability theorem:</p>
<p><strong>Proof.</strong> By reductio ad absurdum: Suppose that there is an <span class="math inline">\(\mathcal{L}\)</span>-formula <span class="math inline">\(\text{True}(n)\)</span> such that for every <span class="math inline">\(\mathcal{L}\)</span>-formula <span class="math inline">\(\varphi\)</span>, <span class="math inline">\(\text{True}(\mathfrak{g}(\varphi)) \leftrightarrow \varphi\)</span>. In particular, if <span class="math inline">\(\sigma\)</span> is a sentence, then <span class="math inline">\(\text{True}(\mathfrak{g}(\sigma))\)</span> holds in <span class="math inline">\(\mathfrak{A}\)</span> iff <span class="math inline">\(\sigma\)</span> is true in <span class="math inline">\(\mathfrak{A}\)</span>. Thus for all <span class="math inline">\(\sigma\)</span>, <span class="math inline">\(\text{True}(\mathfrak{g}(\sigma)) \leftrightarrow \sigma\)</span> holds in <span class="math inline">\(\operatorname{Th}\mathfrak{A}\)</span>. However, by the diagonal lemma, there is also a sentence <span class="math inline">\(\psi\)</span> such that <span class="math inline">\(\psi \leftrightarrow \neg \text{True}(\mathfrak{g}(\mathfrak{\psi}))\)</span> in <span class="math inline">\(\operatorname{Th}\mathfrak{A}\)</span>. That is a contradiction. Therefore, such a formula <span class="math inline">\(\text{True}(n)\)</span> does not exist. <p style='text-align:right !important;text-indent:0 !important;position:relative;top:-1em'>&#9632;</p></p>
<p>Tarski’s undefinability theorem, along with the auxiliary diagonal lemma, showed some really fundamental limitative results in formal logic, and even more. The diagonal lemma obtained its name from the ingenious <a href="https://ncatlab.org/nlab/show/Cantor%27s+theorem">Cantor’s diagonal argument</a>, which reveals the well-known fact that the set <span class="math inline">\(\mathbb{R}\)</span> of all real numbers is uncountable. The similar trick of diagonalization has been exploited in multiple contextually different but essentially interwoven arguments, e.g., Gödel’s incompleteness theorems, and that the halting problem is undecidable. The category-theoretic generalization of this lemma is known as <a href="https://ncatlab.org/nlab/show/Lawvere%27s+fixed+point+theorem">Lawvere’s fixed-point theorem</a>, applicable in any cartesian closed category.</p>
<p>Let’s consider an informal but intuitive connection between the undefinability theorem and the (renowned) incompleteness theorem. Given the fact that the universal truth-telling formula <span class="math inline">\(\text{True}(n)\)</span> is undefinable in a formal language, one may wonder, “If some statement is true, then by the completeness theorem of first-order logic it can always be proven true. But if truth is not even definable at all, how do I know if any statement could as well be <em>proven false</em>?”</p>
<p>Here’s the thing. We don’t. If we do, we would be able to tell truth from falsehood completely and <em>provably</em>. That is to say, for every formula <span class="math inline">\(\varphi\)</span> in our language, there would be either a proof (<span class="math inline">\(\vdash \varphi\)</span>) or a disproof (<span class="math inline">\(\vdash \varphi \to \bot\)</span> or <span class="math inline">\(\vdash \neg \varphi\)</span>) of it; the class of all such proofs would just make a perfect <span class="math inline">\(\text{True}(n)\)</span>, while <span class="math inline">\(\text{True}(\mathfrak{g}(\varphi))\)</span> holds if and only if <span class="math inline">\(\varphi\)</span> has a proof! That would contradict the undefinability theorem. So necessarily, we must take for granted that there could be some falsehood in a logical system (which is powerful enough to represent all computable functions via Gödel numbering, e.g., a number theory of elementary arithmetic) of which existence we can never disprove (because otherwise we could have defined that <span class="math inline">\(\text{True}(n)\)</span>). Plug this metastatement into Löb’s theorem: (Let the modal operator <span class="math inline">\(\square\)</span> denote the modality of provability, and let the constant <span class="math inline">\(\bot\)</span> denote the falsehood.) <span class="math display">\[\begin{align*}
&amp; \square (\square \bot \to \bot) \to \square \bot \\
\iff &amp; \square (\neg \square \bot) \to \square \bot &amp;\qquad\text{(Definition of negation)} \\
\iff &amp; \square (\neg \square \bot) \to \bot &amp;\qquad\text{(Axiom T and transitivity)}\\
\iff &amp; \neg \square (\neg \square \bot) &amp;\qquad\text{(Definition of negation)}\\
\end{align*}\]</span> which informally says “It is not provable that falsehood is not provable.” which is just another way of claiming that <span class="math inline">\(\mathfrak{N} \not\vdash \operatorname{Cons}\mathfrak{N}\)</span>, the consistency of the logical system cannot be proved from within the system itself, a.k.a. Gödel’s second incompleteness theorem.</p>
<p>Digressing a little from our main topic, formal logic, let’s consider the application of the undefinability theorem to programming language theory as a dessert. It is well understood that, by the <a href="https://en.wikipedia.org/wiki/Curry–Howard_correspondence">Curry-Howard correspondence</a>, a logical formula corresponds to a type, and a type checker of a programming language guarantees that every well-typed program consists of only types that correspond to valid formulas. If you write some sophisticated type and its type checking succeeds, the underlying formula must be valid as you have just proved that (so-called “programs are proofs”). Now, I challenge you, given a hypothetical, reasonably expressive programming language with full dependent types, can you write a type-checked <a href="https://en.wikipedia.org/wiki/Meta-circular_evaluator">self-interpreter</a> in it? Once you succeed, you would have proved that you can actually tell valid formulas (types) from false ones in all cases (by writing a self-interpreter that accepts only well-typed programs), thus effectively define the truth in the language itself. By the undefinability theorem, that would be impossible (otherwise your underlying logical system can’t be consistent!). A slightly different but related result is that <em>a total programming language can’t have a self-interpreter</em>; since a total language is not necessarily equipped with a type system or alike proof-theoretic constructions, the undefinability theorem may not directly apply, but a computability-theoretic argument of this is analogously diagonal (see <a href="https://cstheory.stackexchange.com/a/24994/21291">[5]</a>).<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<section id="references" class="level2">
<h2>References</h2>
<p>[1] Wikipedia, “Diagonal lemma”. <a href="https://en.wikipedia.org/wiki/Diagonal_lemma" class="uri">https://en.wikipedia.org/wiki/Diagonal_lemma</a></p>
<p>[2] Wikipedia, “Tarski’s undefinability theorem”. <a href="https://en.wikipedia.org/wiki/Tarski%27s_undefinability_theorem#General_form_of_the_theorem">https://en.wikipedia.org/wiki/Tarski%27s_undefinability_theorem#General_form_of_the_theorem</a></p>
<p>[3] nLab, “Lawvere’s fixed point theorem”. <a href="https://ncatlab.org/nlab/show/Lawvere%27s+fixed+point+theorem">https://ncatlab.org/nlab/show/Lawvere%27s+fixed+point+theorem</a></p>
<p>[4] nLab, “Löb’s theorem”. <a href="https://ncatlab.org/nlab/show/Löb%27s+theorem">https://ncatlab.org/nlab/show/Löb%27s+theorem</a></p>
<p>[5] Andrej Bauer, “Answer to: A total language that only a Turing complete language can interpret”. <a href="https://cstheory.stackexchange.com/a/24994/21291" class="uri">https://cstheory.stackexchange.com/a/24994/21291</a></p>
<p>[6] Matt Brown and Jens Palsberg, “Breaking Through the Normalization Barrier: A Self-Interpreter for F-omega”. <a href="http://compilers.cs.ucla.edu/popl16/popl16-full.pdf" class="uri">http://compilers.cs.ucla.edu/popl16/popl16-full.pdf</a></p>
<p>[7] Jason Gross, Jack Gallagher and Benya Fallenstein, “Löb’s Theorem – A functional pearl of dependently typed quining”. <a href="https://jasongross.github.io/lob-paper/nightly/lob.pdf" class="uri">https://jasongross.github.io/lob-paper/nightly/lob.pdf</a></p>
<p>[8] Herbert B. Enderton, <em>A Mathematical Introduction to Logic</em>, 2nd ed.</p>
</section>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>One may find it intuitive to notice that, whether <span class="math inline">\(\text{True}(\sigma)\)</span> is true or not, it has nothing to do with the existence of God or whatever other claims of real interest. Indeed, instead of restricting our language as we do here, we could as well devise a restrictive set of inference rules for an alternative logic (e.g., <a href="https://plato.stanford.edu/entries/logic-relevance/">relevance logic</a>) so that explosions can be expelled.<a href="#fnref1" class="footnoteBack">↩</a></p></li>
<li id="fn2"><p>I am aware of the “self-interpreter” for System <span class="math inline">\(\text{F}_\omega\)</span> proposed in a POPL’16 paper by Brown &amp; Palsberg <a href="http://compilers.cs.ucla.edu/popl16/popl16-full.pdf">[6]</a>. According to a footnote in <a href="https://jasongross.github.io/lob-paper/nightly/lob.pdf">[7]</a> and also from my unrefined understanding, the interpreter does not come with a separate syntax for types thus fails to capture the underlying logical consistency; therefore neither Löb’s theorem nor the undefinability theorem may apply in that case.<a href="#fnref2" class="footnoteBack">↩</a></p></li>
</ol>
</section>
      </div>
      <!-- (www.soimort.org) last updated: 2016-05-07 -->
      <aside id="soimort-toolbar">
        <a href="/"><i class="fa fa-home" aria-hidden="true"></i></a>
      </aside>
    </article>
  </body>
</html>
