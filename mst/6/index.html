<!DOCTYPE html>
<!-- Akai (pandoc HTML5 template)
     designer:     soimort
     last updated: 2016-05-06
     last adapted: 2016-11-01 -->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <meta name="author" content="Mort Yao">
    <meta name="dcterms.date" content="2017-04-12">
    <title>The Stateful Automata</title>
    <link rel="canonical" href="https://www.soimort.org/mst/6">
    <style type="text/css">code { white-space: pre; }</style>
    <link rel="stylesheet" href="//cdn.soimort.org/normalize/5.0.0/normalize.min.css">
    <link rel="stylesheet" href="//cdn.soimort.org/fonts/latest/URW-Palladio-L.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/__/css/style.css">
    <link rel="stylesheet" href="/__/css/pygments.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
    <script src="//cdn.soimort.org/jk/latest/jk.min.js"></script>
    <script src="/__/js/main.js"></script>
    <link rel="icon" href="/favicon.png">
    <link rel="apple-touch-icon" href="/favicon.png">
    <link rel="alternate" type="application/atom+xml" href="/feed.atom">
  </head>
  <body>
    <article>
      <header>
        <h1 class="title"><a href="https://www.soimort.org/mst/6">The Stateful Automata</a></h1>
        <h1 class="subtitle"><a href="https://www.soimort.org/mst/6">Languages and Computation.</a></h1>
        <address class="author">Mort Yao</address>
        <h3 class="date">2017-04-12</h3>
      </header>
      <div id="content">
<ul>
<li>What is a <a href="https://wiki.soimort.org/comp/language/">formal language</a>? (review of <a href="/mst/1/">Mst. #1</a>)
<ul>
<li>An <em>alphabet</em> <span class="math inline">\(\Sigma\)</span> is a well-defined set of symbols. A <em>string</em> is a sequence of symbols.</li>
<li>A <em>language</em> <span class="math inline">\(L\)</span> over alphabet <span class="math inline">\(\Sigma\)</span> is a set of strings, where each string <span class="math inline">\(w \in \Sigma^*\)</span>.</li>
<li>We can define a <em>class of languages</em> (which is a set of languages with some common properties).</li>
<li>Operations on languages (as sets): <em>union</em>, <em>intersection</em>, <em>complement</em>, <em>concatenation</em>, <em>Kleene star</em>.</li>
<li>A class of languages is said to be <em>closed under some operation</em>, if the operation yields a language that is in the same class. (closure properties)</li>
</ul></li>
<li><a href="https://wiki.soimort.org/comp/language/finite/"><strong>Finite language</strong></a>: Any finite set of strings.
<ul>
<li>Closure properties: FL is closed under union, intersection and concatenation. (but not under complementation or Kleene star)</li>
</ul></li>
<li><a href="https://wiki.soimort.org/comp/language/regular/"><strong>Regular language</strong></a>: Any language that is recognized by a DFA.
<ul>
<li>Closure properties: RL is closed under union, concatenation and Kleene star. (<em>regular operations</em>)</li>
<li>Equivalent models and conversions:
<ul>
<li><strong>DFA</strong> (Deterministic finite automaton)</li>
<li><strong>NFA</strong> (Nondeterministic finite automaton)
<ul>
<li>DFA to NFA: trivial (every DFA is an NFA).</li>
<li>NFA to DFA: powerset (Rabin-Scott construction).</li>
</ul></li>
<li><strong>Regular expression</strong>
<ul>
<li>RegExp to NFA: structural induction (Thompson’s construction).</li>
<li>RegExp to DFA: via NFA (structural induction and powerset).</li>
<li>NFA to RegExp: via GNFA (node removal).</li>
<li>DFA to RegExp: Kleene’s algorithm.</li>
</ul></li>
</ul></li>
<li>Show that a language is regular:
<ol type="1">
<li>By construction: find a DFA/NFA that recognizes it or a RegExp that describes it.</li>
<li>By the Myhill-Nerode theorem.</li>
<li>By hierarchy: every finite language is regular.</li>
</ol></li>
<li>Show that a language is <em>not</em> regular:
<ol type="1">
<li>By the pumping lemma.</li>
<li>By the Myhill-Nerode theorem.</li>
</ol></li>
</ul></li>
</ul>
<figure>
<img src="https://i0.wp.com/dl.dropboxusercontent.com/s/i05152kpetd8xyc/fsm.png" alt="Conversion among different models of RL" style="width:75.0%" /><figcaption>Conversion among different models of RL</figcaption>
</figure>
<ul>
<li>(Nondeterministic) <a href="https://wiki.soimort.org/comp/language/context-free/"><strong>Context-free language</strong></a>: Any language that is generated by a context-free grammar.
<ul>
<li>Closure properties: CFL is closed under union, concatenation and Kleene star. (but not under complementation or intersection)</li>
<li>Equivalent models:
<ul>
<li><strong>Context-free grammar</strong>
<ul>
<li>Every CFG can be converted into <em>Chomsky normal form</em>.</li>
</ul></li>
<li><strong>PDA</strong> (Nondeterministic pushdown automaton)
<ul>
<li>Finite automaton + 1 infinite stack</li>
</ul></li>
</ul></li>
<li>Show that a language is context-free:
<ol type="1">
<li>By construction: find a CFG that generates it or a PDA that recognizes it.</li>
<li>By hierarchy: every regular language is context-free.</li>
</ol></li>
<li>Show that a language is <em>not</em> context-free:
<ol type="1">
<li>By the pumping lemma.</li>
</ol></li>
</ul></li>
<li><a href="https://wiki.soimort.org/comp/church-turing/">Church-Turing thesis</a>
<ul>
<li>It is (informally) a “thesis” because it cannot be formalized as a provable proposition (since we use it to give a notion for what a <em>computation</em> is).</li>
<li>Computation may be performed on <em>unrestricted languages</em>:
<ul>
<li><em>Recognizing</em> a language <span class="math inline">\(L\)</span>:
<ul>
<li>For every string <span class="math inline">\(w \in L\)</span>, the machine <span class="math inline">\(M\)</span> must <em>accept</em> it.</li>
<li>We call such a machine <span class="math inline">\(M\)</span> an <em>acceptor</em> or a <em>recognizer</em> of the language <span class="math inline">\(L\)</span>.</li>
</ul></li>
<li><em>Deciding</em> a language <span class="math inline">\(L\)</span>:
<ul>
<li>For every string <span class="math inline">\(w \in L\)</span>, the machine <span class="math inline">\(M\)</span> must <em>accept</em> it; moreover, for every <span class="math inline">\(w \notin L\)</span>, the machine <span class="math inline">\(M\)</span> must <em>reject</em> it. That is, the machine <span class="math inline">\(M\)</span> must halt on every input <span class="math inline">\(w\)</span>.</li>
<li>We call such a machine <span class="math inline">\(M\)</span> a <em>decider</em> of the language <span class="math inline">\(L\)</span>.</li>
</ul></li>
</ul></li>
<li>Equivalent <em>Turing-complete models of computation</em>:
<ul>
<li>(Single-tape, deterministic, read-write) <strong>Turing machine</strong>
<ul>
<li>Finite automaton + 1 infinite linear table (or 2 infinite stacks)</li>
</ul></li>
<li>Multi-tape Turing machine</li>
<li>Nondeterministic Turing machine</li>
<li>Enumerator</li>
<li>Abstract rewriting system</li>
<li>Lambda calculus (combinatory logic)</li>
<li>…</li>
</ul></li>
<li>The Church-Turing thesis claims that all Turing-complete models are equivalent in their abilities to compute (recognize / decide a language).</li>
<li>There are some languages that cannot be recognized by any Turing machine, that is, <strong>unrecognizable languages</strong> exist. (shown by the diagonal method)</li>
<li><strong>Turing-recognizable language</strong>: Any language that is recognized by a Turing machine.
<ul>
<li>Closure properties: closed under union, intersection, concatenation and Kleene star. (but not under complementation)</li>
</ul></li>
<li><strong>Co-Turing-recognizable language</strong>: Any language whose complement is recognized by a Turing machine.</li>
<li><strong>Turing-decidable language</strong> (or simply <strong>decidable language</strong>): Any language that is decided by a Turing machine.
<ul>
<li>A language is decidable if and only if it is both Turing-recognizable and co-Turing-recognizable.</li>
<li>Closure properties: closed under union, intersection, complementation, concatenation and Kleene star.</li>
</ul></li>
<li>Show that a language is Turing-recognizable:
<ol type="1">
<li>By construction: find a Turing machine that recognizes it.</li>
<li>By mapping reducibility: <span class="math inline">\(L \leq_\text{m} L&#39;\)</span>, where <span class="math inline">\(L&#39;\)</span> is Turing-recognizable.</li>
<li>By hierarchy: any context-sensitive language (thus also context-free language or regular language) is Turing-recognizable.</li>
</ol></li>
<li>Show that a language is <em>not</em> Turing-recognizable:
<ol type="1">
<li>By contraposition: we already know that <span class="math inline">\(\overline{L}\)</span> is Turing-recognizable; if <span class="math inline">\(L\)</span> is Turing-recognizable, then <span class="math inline">\(L\)</span> would be decidable. But we know that <span class="math inline">\(L\)</span> is undecidable, thus <span class="math inline">\(L\)</span> cannot be Turing-recognizable.</li>
<li>By mapping reducibility: <span class="math inline">\(L&#39; \leq_\text{m} L\)</span>, where <span class="math inline">\(L&#39;\)</span> is not Turing-recognizable.</li>
</ol></li>
<li>Show that a language is decidable:
<ol type="1">
<li>By construction: find a Turing machine that decides it.</li>
<li>Show that it is both Turing-recognizable and co-Turing-recognizable.</li>
<li>By mapping reducibility: <span class="math inline">\(L \leq_\text{m} L&#39;\)</span>, where <span class="math inline">\(L&#39;\)</span> is decidable.</li>
<li>By Turing reducibility: <span class="math inline">\(L \leq_\text{T} L&#39;\)</span>, where <span class="math inline">\(L&#39;\)</span> is decidable.</li>
<li>By hierarchy: any context-sensitive language (thus also context-free language or regular language) is decidable.</li>
</ol></li>
<li>Show that a language is <em>undecidable</em>:
<ol type="1">
<li>By mapping reducibility: <span class="math inline">\(L&#39; \leq_\text{m} L\)</span>, where <span class="math inline">\(L&#39;\)</span> is undecidable.</li>
<li>By Rice’s theorem.</li>
</ol></li>
</ul></li>
</ul>
<section id="chomsky-hierarchy-of-languages-grammars-and-automata" class="level2">
<h2>Chomsky hierarchy of languages, grammars and automata</h2>
<p><span class="math display">\[\text{FL} \subsetneq \text{RL} \subsetneq \text{DCFL} \subsetneq \text{CFL} \subsetneq \text{CSL} \subsetneq \text{R} \subsetneq \text{U} \subsetneq \mathcal{P}(\mathcal{P}(\Sigma^*))
\]</span></p>
<ul>
<li>FL (<strong>Finite languages</strong>), described by finite enumeration, recognized by finite Boolean circuits.</li>
<li>RL (<strong>Regular languages</strong>, Type-3 grammars), described by regular expressions, recognized by DFAs/NFAs.</li>
<li>DCFL (<strong>Deterministic context-free languages</strong>), described by deterministic context-free grammars, recognized by deterministic pushdown automata.</li>
<li>CFL (<strong>Context-free languages</strong>, Type-2 grammars), described by nondeterministic context–free grammars, recognized by nondeterministic pushdown automata.</li>
<li>CSL (<strong>Context-sensitive languages</strong>, Type-1 grammars), described by context-sensitive grammars, recognized by linear bounded automata (restricted form of Turing machines).</li>
<li>R (<strong>Turing-decidable languages</strong> or <strong>recursive languages</strong>), described by recursive grammars, recognized by Turing machines that always halt (i.e., deciders).</li>
<li>U (<strong>Turing-recognizable languages</strong> or <strong>recursively enumerable languages</strong>, Type-0 grammars), described by unrestricted grammars, recognized by Turing machines (but not guaranteed to halt thus not necessarily decidable).</li>
<li><span class="math inline">\(\mathcal{P}(\mathcal{P}(\Sigma^*))\)</span>, may have unrestricted grammars or no grammar at all, not necessarily Turing-recognizable.</li>
</ul>
<p><em>Grammars</em> provide a mathematical, recursive perspective for describing languages, while <em>automata</em> provide a physically implementable, iterative approach of recognizing languages (via finite states and possibly infinite stacks). A language is Turing-recognizable if and only if it has a well-defined grammar (so that it’s possible to construct some Turing machine that recognizes it), although it can sometimes be hard to formulate. Quite naturally, if we cannot specify a grammar for a language <span class="math inline">\(L \subset \mathcal{P}(\Sigma^*)\)</span> theoretically, it would be impossible to construct a Turing machine that recognizes it.</p>
</section>
<section id="decidability-and-undecidability" class="level2">
<h2>Decidability and undecidability</h2>
<p>We consider mainly three types of decision problems concerning different computational models: (generative grammars may be viewed as a form of machines like automata, in the following setting)</p>
<ol type="1">
<li>Acceptance problem: <span class="math inline">\(A_\mathsf{X} = \{ \langle M, w\rangle\ |\ M \text{ is a machine of type } X \text{, and } M \text{ accepts } w \}\)</span>.</li>
<li>Emptiness problem: <span class="math inline">\(E_\mathsf{X} = \{ \langle M \rangle\ |\ M \text{ is a machine of type } X \text{, and } \mathcal{L}(M) = \emptyset \}\)</span>.</li>
<li>Equality problem: <span class="math inline">\(EQ_\mathsf{X} = \{ \langle M_1, M_2 \rangle\ |\ M_1 \text{ and } M_2 \text{ are machines of type } X \text{, and } \mathcal{L}(M_1) = \mathcal{L}(M_2) \}\)</span>.</li>
</ol>
<table style="width:96%;">
<colgroup>
<col style="width: 8%" />
<col style="width: 12%" />
<col style="width: 26%" />
<col style="width: 25%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th>Model</th>
<th>Language</th>
<th>Acceptance problem</th>
<th>Emptiness problem</th>
<th>Equality problem</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DFA <br>(Deterministic finite automaton)</td>
<td>Regular language: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(A_\textsf{DFA}\)</span>: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(E_\textsf{DFA}\)</span>: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(EQ_\textsf{DFA}\)</span>: <strong><em>decidable</em></strong></td>
</tr>
<tr class="even">
<td>NFA <br>(Nondeterministic finite automaton)</td>
<td>Regular language: <strong>decidable</strong></td>
<td><span class="math inline">\(A_\textsf{NFA}\)</span>: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(E_\textsf{NFA}\)</span>: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(EQ_\textsf{NFA}\)</span>: <strong><em>decidable</em></strong></td>
</tr>
<tr class="odd">
<td>Regular expression</td>
<td>Regular language: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(A_\textsf{REX}\)</span>: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(E_\textsf{REX}\)</span>: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(EQ_\textsf{REX}\)</span>: <strong><em>decidable</em></strong></td>
</tr>
<tr class="even">
<td>CFG <br>(Context-free grammar)</td>
<td>Context-free language: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(A_\textsf{CFG}\)</span>: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(E_\textsf{CFG}\)</span>: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(EQ_\textsf{CFG}\)</span>: <em>undecidable</em></td>
</tr>
<tr class="odd">
<td>PDA <br>(Pushdown automaton)</td>
<td>Context-free language: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(A_\textsf{PDA}\)</span>: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(E_\textsf{PDA}\)</span>: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(EQ_\textsf{PDA}\)</span>: <em>undecidable</em></td>
</tr>
<tr class="even">
<td>CSG <br>(Context-sensitive grammar)</td>
<td>Context-sensitive language: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(A_\textsf{CSG}\)</span>: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(E_\textsf{CSG}\)</span>: <em>undecidable</em></td>
<td><span class="math inline">\(EQ_\textsf{CSG}\)</span>: <em>undecidable</em></td>
</tr>
<tr class="odd">
<td>LBA <br>(Linear bounded automaton)</td>
<td>Context-sensitive language: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(A_\textsf{LBA}\)</span>: <strong><em>decidable</em></strong></td>
<td><span class="math inline">\(E_\textsf{LBA}\)</span>: <em>undecidable</em></td>
<td><span class="math inline">\(EQ_\textsf{LBA}\)</span>: <em>undecidable</em></td>
</tr>
<tr class="even">
<td>Turing machine and equivalent Turing-complete models</td>
<td>Turing-recognizable language: may be <strong><em>decidable</em></strong> or <em>undecidable</em></td>
<td><span class="math inline">\(A_\textsf{TM}\)</span>: <em>undecidable</em></td>
<td><span class="math inline">\(E_\textsf{TM}\)</span>: <em>undecidable</em></td>
<td><span class="math inline">\(EQ_\textsf{TM}\)</span>: <em>undecidable</em> <br>(not Turing-recognizable)</td>
</tr>
</tbody>
</table>
<p>The fact that <span class="math inline">\(A_\mathsf{TM}\)</span> is undecidable implies that a Turing machine may not halt on some input <span class="math inline">\(w\)</span>. Consider the following problem: (<strong>the halting problem</strong> <span class="citation" data-cites="turing1937computable">[1]</span>) <span class="math display">\[\textit{HALT}_\textsf{TM} = \{ \langle M, w \rangle\ | \ M \text{ is a TM, and } M \text{ halts on input } w \}\]</span></p>
<p><strong>Corollary 6.1.</strong> <span class="math inline">\(\textit{HALT}_\textsf{TM}\)</span> is undecidable.</p>
<p><strong>Proof.</strong> (By contraposition) Assume that there exists a Turing machine <span class="math inline">\(R\)</span> that decides <span class="math inline">\(\textit{HALT}_\textsf{TM}\)</span>. We construct a Turing machine <span class="math inline">\(S\)</span> that decides <span class="math inline">\(A_\mathsf{TM}\)</span>, using <span class="math inline">\(R\)</span>:</p>
<blockquote>
<p><span class="math inline">\(S =\)</span> “On input <span class="math inline">\(\langle M, w \rangle\)</span>:</p>
<ol type="1">
<li>Run <span class="math inline">\(R\)</span> on input <span class="math inline">\(\langle M, w \rangle\)</span>.</li>
<li>If <span class="math inline">\(R\)</span> rejects, reject.</li>
<li>If <span class="math inline">\(R\)</span> accepts (so that we know <span class="math inline">\(M\)</span> always halt on <span class="math inline">\(w\)</span>), simulate <span class="math inline">\(M\)</span> on <span class="math inline">\(w\)</span> until it halts.</li>
<li>If <span class="math inline">\(M\)</span> accepts, accept; otherwise, reject.’’</li>
</ol>
</blockquote>
<p>If <span class="math inline">\(R\)</span> decides <span class="math inline">\(\textit{HALT}_\textsf{TM}\)</span>, then <span class="math inline">\(S\)</span> decides <span class="math inline">\(A_\mathsf{TM}\)</span> by construction. Since <span class="math inline">\(A_\mathsf{TM}\)</span> is undecidable, such an <span class="math inline">\(R\)</span> that decides <span class="math inline">\(\textit{HALT}_\textsf{TM}\)</span> does not exist. <p style='text-align:right !important;text-indent:0 !important;position:relative;top:-1em'>&#9632;</p></p>
<p>Apart from Turing’s original halting problem, other undecidable problems of historical importance include:</p>
<ul>
<li><strong>Post correspondence problem</strong> (Post 1946 <span class="citation" data-cites="post1946variant">[2]</span>)</li>
<li><strong>Word problem for semigroups</strong> (proposed by Axel Thue in 1914; its undecidability was shown by Emil Post and Andrey Markov Jr. independently in 1947 <span class="citation" data-cites="post1947recursive">[3]</span>)</li>
<li><strong>The busy beaver game</strong> (Rado 1962 <span class="citation" data-cites="rado1962non">[4]</span>)</li>
<li><strong>Hilbert’s tenth problem</strong> (proposed by D. Hilbert in 1900; its undecidability was shown by Matiyasevich’s theorem in 1970, and is in no way an obvious result)</li>
</ul>
<p>Some problems, such as <span class="math inline">\(EQ_\mathsf{TM}\)</span>, are not even Turing-recognizable. Another example is <span class="math inline">\(MIN_\mathsf{TM}\)</span>: <span class="math display">\[MIN_\mathsf{TM} = \{ \langle M \rangle\ | \ M \text{ is a minimal Turing machine} \}\]</span></p>
<p><strong>Theorem 6.2.</strong> <span class="math inline">\(MIN_\mathsf{TM}\)</span> is not Turing-recognizable.</p>
<p><strong>Proof.</strong> Assume that there exists an enumerator <span class="math inline">\(E\)</span> that enumerates <span class="math inline">\(MIN_\mathsf{TM}\)</span> (note that an enumerator is equivalent to a Turing machine). We construct a Turing machine <span class="math inline">\(C\)</span> using <span class="math inline">\(E\)</span>:</p>
<blockquote>
<p><span class="math inline">\(C =\)</span> “On input <span class="math inline">\(w\)</span>:</p>
<ol type="1">
<li>Obtain the own description <span class="math inline">\(\langle C \rangle\)</span>. (by the recursion theorem)</li>
<li>Run <span class="math inline">\(E\)</span> until a machine <span class="math inline">\(D\)</span> appears with a longer description than that of <span class="math inline">\(C\)</span>.</li>
<li>Simulate <span class="math inline">\(D\)</span> on <span class="math inline">\(w\)</span>.’’</li>
</ol>
</blockquote>
<p>Since <span class="math inline">\(MIN_\textsf{TM}\)</span> is infinitely large but the description of <span class="math inline">\(C\)</span> is of finite length, the enumerator <span class="math inline">\(E\)</span> must eventually terminate with some <span class="math inline">\(D\)</span> that has a longer description than that of <span class="math inline">\(C\)</span>. As <span class="math inline">\(C\)</span> simulates <span class="math inline">\(D\)</span> in the last step, <span class="math inline">\(C\)</span> is equivalent to <span class="math inline">\(D\)</span>. But then the description of <span class="math inline">\(C\)</span> is shorter than that of <span class="math inline">\(D\)</span>, thus <span class="math inline">\(D\)</span> could not be an output of <span class="math inline">\(E\)</span> (which enumerates only <span class="math inline">\(MIN_\mathsf{TM}\)</span>). That is a contradiction. Therefore, such an enumerator <span class="math inline">\(E\)</span> for <span class="math inline">\(MIN_\mathsf{TM}\)</span> does not exist, that is, <span class="math inline">\(MIN_\mathsf{TM}\)</span> is not Turing-recognizable. <p style='text-align:right !important;text-indent:0 !important;position:relative;top:-1em'>&#9632;</p></p>
<p>The Turing-unrecognizability of <span class="math inline">\(MIN_\textsf{TM}\)</span> implies that the Kolmogorov complexity (descriptive complexity) <span class="math inline">\(K(x)\)</span> is not a computable function.</p>
</section>
<section id="beyond-turing-machines" class="level2">
<h2>Beyond Turing machines</h2>
<p>Per the Church-Turing thesis, a Turing machine (one finite automaton + one infinite linear table) defines the “limitation of computation”. Several hypothetical models (sometimes referred to as <em>hypercomputation</em> <span class="citation" data-cites="davis2004myth">[5]</span> as they are assumed to have the abilities to solve non-Turing-computable problems) have been proposed for the sake of theoretical interest:</p>
<ul>
<li><strong>Oracle machine</strong>: a know-all machine that can solve a certain non-Turing-computable problem such as <span class="math inline">\(A_\textsf{TM}\)</span> or <span class="math inline">\(\textit{HALT}_\textsf{TM}\)</span> (in a black-boxed way).</li>
<li><strong>Real computer</strong> (e.g., Blum-Shub-Smale machine): an idealized analog computer that can compute infinite-precision real numbers. (Real numbers are uncountable as shown by Cantor’s diagonal argument, so Turing machines are incapable of handling arbitrary reals)</li>
<li><strong>Zeno machine</strong> (i.e., supertasking): a Turing machine that can complete infinitely many steps in finite time.</li>
<li><strong>Infinite-time Turing machine</strong>: a Turing machine that is simply allowed to halt in an infinite amount of time.</li>
</ul>
<p>Note that standard (qubit-based) quantum computers are PSPACE-reducible, thus they are still a Turing-complete model of computation (i.e., quantum computers cannot be real computers or Zeno machines, and they do not break the Church-Turing thesis). Moreover, it has been proposed that the simulation of every (quantum) physical process, where only computable reals present, is actually a Turing-computable problem (Church-Turing-Deutsch principle).</p>
</section>
<section id="notes-on-interesting-problems-in-computability-theory" class="level2">
<h2>Notes on interesting problems in computability theory</h2>
<p><strong>Finite languages.</strong> A finite language consists of a finite set of strings, thus it may be written as a regular expression of a finite union of those strings. It may be recognized by a time-independent combinational circuit, which can be viewed as a special form of acyclic finite automaton. (See also the blog post: <a href="https://blog.soimort.org/comp/c/boolean-circuit/">What I Wish I Knew When Learning Boolean Circuits</a>) There are several unsolved problems concerning the circuit complexity.</p>
<p><strong>Generalized regular expression.</strong> A generalized regular expression is defined as <span class="math display">\[R ::= a\ |\ \varepsilon\ |\ \emptyset\ |\ (R_1 \cup R_2)\ |\ (R_1 \cap R_2)\ |\ (R_1 \circ R_2)\ |\ (\lnot R_1)\ |\ (R_1^*)\]</span> where <span class="math inline">\(a \in \Sigma\)</span>, <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> are generalized regular expressions. Although it comes with two extra operators (intersection <span class="math inline">\(\cap\)</span> and complementation <span class="math inline">\(\lnot\)</span>), it actually has the same representational power as regular expressions, due to the fact that the class of regular languages is closed under intersection and complementation.</p>
<p><strong>Star-free languages.</strong> A star-free language is a regular language that can be described by a generalized regular expression but without the Kleene star operation. Clearly, this class includes all finite languages. One example of an infinite star-free language is <span class="math inline">\(a^*\)</span>, because <span class="math inline">\(a^* = \lnot((\lnot\emptyset) \circ (\lnot{a}) \circ (\lnot\emptyset))\)</span>. On the other hand, <span class="math inline">\((a \circ a)^*\)</span> is not star-free.</p>
<p>(Unsolved) <strong>Generalized star height problem.</strong> Can all regular languages be expressed using generalized regular expressions with a limited nesting depth of Kleene stars (star height)? Moreover, is the minimum required star height a computable function? For example, <span class="math inline">\(((((a \circ a)^*)^*)\cdots)^*\)</span> can be expressed as <span class="math inline">\((a \circ a)^*\)</span>, which has a minimum required star height of 1 (but it is not star-free). The general result and whether the minimum star height is decidable are not yet known.</p>
<p><strong>Linear bounded automata.</strong> LBAs provide an accurate model for real-world computers, which have only bounded memories. Given sufficient memory on an LBA, we can simulate another (smaller) LBA; a practical example would be a virtual machine running on VirtualBox or QEMU.</p>
<p>(Unsolved) <strong>LBA problem.</strong> Is the class of languages accepted by LBA equal to the class of languages accepted by deterministic LBA? Or, in terms of the complexity theory, is <span class="math inline">\(\text{SPACE}(n) = \text{NSPACE}(n)\)</span>? We know that DFA and NFA accept the same class of languages, so do TM and NTM, while PDA and DPDA are not completely equivalent. However, it is still an open question whether LBA and DLBA are equivalent models. Note that it is known that <span class="math inline">\(\text{PSPACE} = \bigcup_k \text{SPACE}(n^k)\)</span> is equivalent to <span class="math inline">\(\text{NPSPACE} = \bigcup_k \text{NSPACE}(n^k)\)</span>, that is, deterministic polynomially bounded automata and nondeterministic polynomially bounded automata are equivalent, by Savitch’s theorem.</p>
</section>
<section id="references-and-further-reading" class="level2">
<h2>References and further reading</h2>
<p><strong>Books:</strong></p>
<p>M. Sipser, <em>Introduction to the Theory of Computation</em>, 3rd ed.</p>
<p>J. E. Hopcroft, R. Motwani, J. D. Ullman, <em>Introduction to Automata Theory, Languages, and Computation</em>, 3rd ed.</p>
<p><strong>Articles:</strong></p>
<p>M. Davis, “What is a computation?” <em>Mathematics Today: Twelve Informal Essays</em>, pp. 241–267, 1978.</p>
<p>D. Zeilberger, “A 2-minute proof of the 2nd-most important theorem of the 2nd millennium,” <a href="http://www.math.rutgers.edu/~zeilberg/mamarim/mamarimTeX/halt" class="uri">http://www.math.rutgers.edu/~zeilberg/mamarim/mamarimTeX/halt</a>.</p>
<p><strong>Papers:</strong></p>
<div id="refs" class="references">
<div id="ref-turing1937computable">
<p>[1] A. M. Turing, “On computable numbers, with an application to the Entscheidungsproblem,” <em>Proceedings of the London Mathematical Society</em>, vol. 2, no. 1, pp. 230–265, 1937. </p>
</div>
<div id="ref-post1946variant">
<p>[2] E. L. Post, “A variant of a recursively unsolvable problem,” <em>Bulletin of the American Mathematical Society</em>, vol. 52, no. 4, pp. 264–268, 1946. </p>
</div>
<div id="ref-post1947recursive">
<p>[3] E. L. Post, “Recursive unsolvability of a problem of Thue,” <em>The Journal of Symbolic Logic</em>, vol. 12, no. 01, pp. 1–11, 1947. </p>
</div>
<div id="ref-rado1962non">
<p>[4] T. Rado, “On non-computable functions,” <em>Bell System Technical Journal</em>, vol. 41, no. 3, pp. 877–884, 1962. </p>
</div>
<div id="ref-davis2004myth">
<p>[5] M. Davis, “The myth of hypercomputation,” in <em>Alan Turing: Life and legacy of a great thinker</em>, Springer, 2004, pp. 195–211. </p>
</div>
</div>
</section>
      </div>
      <!-- (www.soimort.org) last updated: 2016-05-07 -->
      <aside id="soimort-toolbar">
        <a href="/"><i class="fa fa-home" aria-hidden="true"></i></a>
      </aside>
    </article>
  </body>
</html>
